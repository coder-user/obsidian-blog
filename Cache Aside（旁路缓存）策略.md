# Cache Aside（旁路缓存）策略

最常见的缓存策略。

![[Cache Aside（旁路缓存）策略_image_1.png]]

- **更新数据**：不更新缓存，而是删除缓存中的数据
- **读取数据**：发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中

> [!question] 像 Cache Aside 策略这样先更新数据库，后删除缓存就没有问题了吗？

其实在理论上还是有缺陷的，可能会导致数据不一致。

![[Cache Aside（旁路缓存）策略_image_2.png]]

**Cache Aside 策略**是我们日常开发中==最经常使用的缓存策略==，不过我们在使用时也要学会依情况而变。

> [!example]  当新注册一个用户

当**注册用户后立即读取用户信息**，并且数据库主从分离时，会出现因为主从延迟所以读不到用户信息的情况。
而解决这个问题的办法恰恰是在插入新数据到数据库之后写入缓存，这样后续的读请求就会从缓存中读到数据了。并且因为是新注册的用户，所以不会出现并发更新用户信息的情况。

> [!note] Cache Aside 存在的最大的问题：

当「写入比较频繁」时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。

如果你的业务==对缓存命中率有严格的要求==，那么可以**考虑两种解决方案**：

1. 一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；
2. 另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快地过期，对业务的影响也是可以接受。