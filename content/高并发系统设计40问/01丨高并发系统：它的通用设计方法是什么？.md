> [!question] 高并发系统设计三个通用的方法是什么？

- **Scale-out（横向扩展）**：分而治之是一种常见的高并发系统设计方法，采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。
- **缓存**：使用[缓存](12丨缓存：数据库成为瓶颈后，动态数据的查询要如何加速？.md)来提高系统的性能，主要提高查询性能。
- **异步**：在某些场景下，未处理完成之前，我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。

## 1 Scale-up Vs Scale-out

**Scale-up**：通过购买性能更好的硬件来提升系统的并发处理能力。
**Scale-out**：则是另外一个思路，它通过将多个低性能的机器组成一个分布式集群来共同抵御高并发流量的冲击。

> [!question] 那么什么时候选择 Scale-up，什么时候选择 Scale-out 呢？

系统设计初期会考虑使用 Scale-up 的方式，因为这种方案足够简单，所谓能用堆砌硬件解决的问题就用硬件来解决，但是当系统并发超过了单机的极限时，我们就要使用 Scale-out 的方式。

Scale-out 虽然能够突破单机的限制，但也会引入一些复杂问题。

1. 如果某个节点出现故障如何保证整体可用性？
2. 当多个节点有状态需要同步时，如何保证状态信息在不同节点的一致性？
3. 如何做到使用方无感知的增加和删除节点？

## 2 使用缓存提升性能

使用缓存的主要作用是提升系统的**访问性能**，那么在高并发的场景下，就可以支撑更多用户的**同时访问**（系统的读性能）。

> [!tip] 系统硬件时间对比?

普通磁盘的寻道时间是 10ms 左右，而相比于磁盘寻道花费的时间，CPU 执行指令和内存寻址的时间都在是 ns（纳秒）级别，从千兆网卡上读取数据的时间是在μs（微秒）级别。

我们通常使用以内存作为存储介质的缓存，以此提升性能。

缓存的语义已经丰富了很多，我们可以将**任何降低响应时间的中间存储都称为缓存**。

## 3 异步处理

> [!question]  什么是同步，什么是异步呢？

以方法调用为例：

**同步调用**：代表调用方要阻塞等待被调用方法中的逻辑执行完成。这种方式下，当被调用方法响应时间较长时，会造成调用方长久的阻塞，在高并发下会造成整体系统性能下降**甚至发生雪崩**。
**异步调用**：恰恰相反，调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。

## 4 总结

既然我们了解了这三种方法，那么是不是意味着在高并发系统设计中，开发一个系统时要把这些方法都用上呢？

当然不是，系统的设计是不断演进的。 **罗马不是一天建成的，系统的设计也是如此**

**建议一般系统的演进过程应该遵循下面的思路**

1. 最简单的系统设计满足业务需求和流量现状，选择最熟悉的技术体系。随着流量的增加和业务的变化，修正架构中存在问题的点，如单点问题，横向扩展问题，性能无法满足需求的组件。在这个过程中，选择社区成熟的、团队熟悉的组件帮助我们解决问题，在社区没有合适解决方案的前提下才会自己造轮子。
2. 当对架构的小修小补无法满足需求时，考虑重构、重写等大的调整方式以解决现有的问题。

==归根结底一句话==：**高并发系统的演进应该是循序渐进，以解决系统中存在的问题为目的和驱动力的**。
