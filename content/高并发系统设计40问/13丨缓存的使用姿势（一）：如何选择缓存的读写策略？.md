# 13丨缓存的使用姿势（一）：如何选择缓存的读写策略？

> [!info] 使用缓存的正确姿势 #缓存

- 缓存的读写策略是怎么样的
- 如何做到缓存高可用
- 如何应对缓存穿透

> [!important] 选择策略时也需要考虑诸多的因素:

- 缓存中是否有可能被写入脏数据
- 策略的读写性能如何
- 是否存在缓存命中率下降的情况等等

## 1 Cache Aside（旁路缓存）策略

使用缓存最常见的策略。

![[800-ob/000-attachments/13丨缓存的使用姿势（一）：如何选择缓存的读写策略？_image_1.png]]

在更新数据时不更新缓存，而是删除缓存中的数据，在读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。

> [!question] 像 Cache Aside 策略这样先更新数据库，后删除缓存就没有问题了吗？

其实在理论上还是有缺陷的：

![[13丨缓存的使用姿势（一）：如何选择缓存的读写策略？_image_2.png]]

可能会导致数据不一致。

**Cache Aside 策略**是我们日常开发中==最经常使用的缓存策略==，不过我们在使用时也要学会依情况而变。

> [!example]  场景一：当新注册一个用户

当**注册用户后立即读取用户信息**，并且数据库主从分离时，会出现因为主从延迟所以读不到用户信息的情况。
而解决这个问题的办法恰恰是在插入新数据到数据库之后写入缓存，这样后续的读请求就会从缓存中读到数据了。并且因为是新注册的用户，所以不会出现并发更新用户信息的情况。

> [!note] Cache Aside 存在的最大的问题：

当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。

如果你的业务==对缓存命中率有严格的要求==，那么可以**考虑两种解决方案**：

1. 一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；
2. 另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快地过期，对业务的影响也是可以接受。

## 2 Read/Write Through（读穿 / 写穿）策略

核心原则是用户只与缓存打交道，由缓存和数据库通信，写入或者读取数据。

### 2.1 Write Through 的策略

先查询要写入的数据在缓存中是否已经存在，如果已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，如果缓存中数据不存在，我们把这种情况叫做 `Write Miss`（写失效）。

两种 `Write Miss` 方式：

1. `Write Allocate`（按写分配），做法是写入缓存相应位置，再由缓存组件同步更新到数据库中
2. `No-write allocate`（不按写分配），做法是不写入缓存中，而是直接更新到数据库中。（一般选择）

### 2.2 Read Through 策略

先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库中同步加载数据。

![[800-ob/000-attachments/13丨缓存的使用姿势（一）：如何选择缓存的读写策略？_image_3.png]]

`Read Through/Write Through` 策略的特点是由缓存节点而非用户来和数据库打交道，在发过程中相比 Cache Aside 策略要**少见一些**，原因是经常使用的分布式缓存组件，无论是 Memcached 还是 Redis 都不提供写入数据库，或者自动加载数据库中的数据的功能。

**在使用本地缓存的时候可以考虑使用这种策略**

## 3 Write Back（写回）策略

**核心思想**是在写入数据时只写入缓存，并且把缓存块儿标记为**脏**的。而脏块儿只有被再次使用时才会将其中的数据写入到后端存储中。

在 `Write Miss` 的情况下，采用的是 `Write Allocate` 的方式，也就是在写入后端存储的同时要写入缓存，这样在之后的写请求中都只需要更新缓存即可，而无需更新后端存储了。

**Write back 策略的示意图**：

![[13丨缓存的使用姿势（一）：如何选择缓存的读写策略？_image_4.png]]

如果使用 Write Back 策略的话，读的策略也有一些变化了:

![[13丨缓存的使用姿势（一）：如何选择缓存的读写策略？_image_5.png]]

> [!bug] Write Back 的问题

不能被应用到我们常用的数据库和缓存的场景中，它是计算机体系结构中的设计，比如我们在向磁盘中写数据时采用的就是这种策略。（因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏块儿数据丢失。）

**依然可以在一些场景下使用这个策略，在使用时，我想给你的落地建议是：**

在向低速设备写入数据的时候，可以在内存里先暂存一段时间的数据，甚至做一些统计汇总，然后定时地刷新到低速设备上。

- eg：在统计你的接口响应时间的时候，需要将每次请求的响应时间打印到日志中，然后监控系统收集日志后再做统计。但是如果每次请求都打印日志无疑会增加磁盘 I/O，那么不如把一段时间的响应时间暂存起来，经过简单的统计平均耗时，每个耗时区间的请求数量等等，然后定时地，批量地打印到日志中。

## 4 总结

缓存使用的几种策略，以及每种策略适用的使用场景是怎样的。

1. `Cache Aside` 是我们在使用分布式缓存时最常用的策略，你可以在实际工作中直接拿来使用。
2. `Read/Write Through` 和 `Write Back` 策略需要缓存组件的支持，所以比较适合你在**实现本地缓存组件**的时候使用；
3. `Write Back` 策略是计算机体系结构中的策略，不过写入策略中的只写缓存，异步写入后端存储的策略倒是有很多的应用场景。

提到的策略都是标准的使用姿势，在实际开发过程中需要结合实际的业务特点灵活使用甚至加以改造。这些业务特点包括但不仅限于：整体的数据量级情况，访问的读写比例的情况，对于数据的不一致时间的容忍度，对于缓存命中率的要求等等。理论结合实践，具体情况具体分析，你才能得到更好的解决方案。

> [!tip] 缓存一定会引入不一致

解决的办法需要权衡一致性和性能。

分布式锁也可以解决缓存不一致问题。

## 5 问题和回答

问题：
老师问您一个问题！其实如果是使用. Cache Aside 方式的话。在写的时候时候因为更新数据后，删除了缓存。在高并发情况下。那么可能会出现以下情况：  主从同步的情况下，从库没来得及同步。大量的读请求返回的是从库的旧数据。而这个时候读的数据会被动写入缓存。那就存在很大的问题！这种应该怎么处理！如果是这样的话？是不是只能依靠分布式锁来实现了！

回答：
是的 这样只能更新缓存，然后使用分布式锁来控制

问题：
老师你好，请问下 Redis 不是一个单线程模型么，那么在其中他的分布式锁有什么含义么，不是不会产生锁竞争么？还是只有在集群中 Redis 的分布式锁有用，如果是单节点的 Redis 是否就不需要，对这一块一直有疑问。谢谢老师

回答：
这里的分布式锁指的是引用层加锁，你想如果两个线程更新数据库和缓存的顺序不同，会产生数据不一致；redis 本身的操作是原子的

问题：
老师请问一个问题，在 cache aside 策略中，如果先更新数据库，再删除缓存。这样如果读请求访问量很大，会短时间出现大量请求穿透到数据库，这里有好的办法优化吗？

回答：
如果更新不频繁的话，其实还 OK  如果更新频繁，可以加分布式锁，让单一线程可以更新这条数据；或者设置短的过期时间，让可能出现的不一致数据尽快过期

问题：
老师，我没有明白 Cache Aside 为什么使用分布式锁就解决了问题，这样多个写入同时到达时只有一个能成功写入，也不一定是最后一次的写入成功吧

回答：
可能我没有表述清楚。因为 Cache aside 会清空缓存，所以会对命中率有影响。那么如果不清空缓存，还要保证一致性，可以在更新数据之前先加分布式锁，同时只有一个线程更新数据，当然这样对写入性能有影响。
